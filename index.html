<html>
<head>
	<style>
		.case {
			width:50px;
			height:50px;
			border:0.5px solid black;
			float:left;
			text-align: center;
			font-size: 2em;
		}
		.piece {
			width: 100%;
			height: 100%;
		}
		.white {
			background-color:white;
		}
		.black {
			background-color:lightslategray;
		}
		.selected {
			background-color: yellow;
		}
		.highlighted {
			background-color: lightgreen;
		}
		#moves {
			float: left
		}
	</style>
</head>
<body>
	Chess Game
	<div id="board"></div>
	<div id="moves"></div>
	<script type="text/javascript">
	
		let selectedSquare
		let pieceCounter = 0
		let chessBoard = []
		let moves = []
		
		const COLOR = {
			BLACK:"BLACK",
			WHITE:"WHITE"
		}

		class Square {
			constructor(i, j, color, piece, selected = false, highlighted = false) {
				this.i = i
				this.j = j
				this.color = color
				this.piece = piece
				this.selected = selected
				this.highlighted = highlighted
			}
			getHTML() {
				return "<div class='case "+this.color+" "+(this.selected ? "selected":"")+" "+ (this.highlighted ? "highlighted" : "") +"' id='"+this.getHtmlId()+"' data-i='"+this.i+"' data-j='"+this.j+"' >"
				+(this.piece ? this.piece.getHTML() : "")+
				"</div>"
			}
			setPiece(piece) {
				this.piece = piece;
				if (piece) piece.square = this;
			}
			getHtmlId() {
				return `c-${this.i}-${this.j}`
			}
		}
		
		class Move {
			constructor(piece, initialSquare, newSquare) {
				this.piece = piece
				this.initialSquare = initialSquare
				this.newSquare = newSquare
			}
			getString() {
				return `Piece ${this.piece.name} moved from ${this.initialSquare.i},${this.initialSquare.j} to ${this.newSquare.i},${this.newSquare.j}`
			}
		}

		class Piece {
			constructor(name, color, square) {
				this.name = name;
				this.color = color;
				this.square = square;
				this.ID = pieceCounter++;
			}
			getHTML() {
				return "<div class='piece' id='"+this.getHtmlId()+"'>"+this.getSymbol()+"</div>"
			}
			beforeMoveEvent(newSquare) {
				moves.push(new Move(this, this.square, newSquare))
			}
			afterMoveEvent() {
				console.log(`Piece ${this.name} moved to ${this.square.i},${this.square.j}`)
			}
			getHtmlId() {
				return `piece-${this.ID}`
			}
		}
		
		class Pawn extends Piece {
			constructor(color) {
				super ('pawn', color)
				this.isAtInitialSquare = true
			}
			getPossibleMoves() {
				let moves = []
				let di = this.color == COLOR.BLACK ? 1 : -1
				let ahead = neighbour(this.square, di, 0)
				if (ahead && !ahead.piece) moves.push(ahead)
				
				if (this.isAtInitialSquare) {
					let aheadTwice = neighbour(this.square, di*2, 0)
					if (aheadTwice && !aheadTwice.piece) moves.push(aheadTwice)		
				}

				let aheadLeft = neighbour(this.square, di, -1)
				if (aheadLeft && aheadLeft.piece && aheadLeft.piece.color != this.color) moves.push(aheadLeft)
				
				let aheadRight = neighbour(this.square, di, 1)
				if (aheadRight && aheadRight.piece && aheadRight.piece.color != this.color) moves.push(aheadRight)
				
				//console.log(moves)
				return moves
			}
			getSymbol() {
				return this.color == COLOR.BLACK ? "&#9823;" : "&#9817;"
			}
			afterMoveEvent() {
				this.isAtInitialSquare = false
			}
		}

		class Knight extends Piece {
			constructor(color) {
				super('knight', color) 
			}
			getPossibleMoves() {
				let moves = []
				const predicate = (square) => (square && !square.piece) || (square && square.piece && square.piece.color != this.color)

				this.addMove(moves, neighbour(this.square, -1, -2), predicate)
				this.addMove(moves, neighbour(this.square, -1, 2), predicate)
				
				this.addMove(moves, neighbour(this.square, -2, -1), predicate)
				this.addMove(moves, neighbour(this.square, -2, 1), predicate)
				
				this.addMove(moves, neighbour(this.square, 1, -2), predicate)
				this.addMove(moves, neighbour(this.square, 1, 2), predicate)
				
				this.addMove(moves, neighbour(this.square, 2, -1), predicate)
				this.addMove(moves, neighbour(this.square, 2, 1), predicate)
				
				//console.log(moves)
				return moves
			}
			addMove(moves, square, predicate) {
				if (predicate(square))
					moves.push(square)
			}
			getSymbol() {
				return this.color != COLOR.BLACK ? "&#9816;" : "&#9822;"
			}
		}

		class Rook extends Piece {
			constructor(color) {
				super('rook', color) 
			}
			getSymbol() {
				return (this.color == COLOR.BLACK) ? "&#9820;" : "&#9814;"
			}
			getPossibleMoves() {
				let moves = []	
				const predicate = (square) => (square && !square.piece) || (square && square.piece && square.piece.color != this.color)

				for (let i = this.square.i - 1; i >= 0; i--) {
					let s = chessBoard[i][this.square.j]
					if (predicate(s)) {
						moves.push(s)
						if (s.piece && s.piece.color != this.color) break
					} else break
				}

				for (let i = this.square.i + 1; i < 8; i++) {
					let s = chessBoard[i][this.square.j]
					if (predicate(s)) {
						moves.push(s)
						if (s.piece && s.piece.color != this.color) break
					} else break
				}

				for (let j = this.square.j - 1; j >= 0; j--) {
					let s = chessBoard[this.square.i][j]
					if (predicate(s)) {
						moves.push(s)
						if (s.piece && s.piece.color != this.color) break
					} else break
				}

				for (let j = this.square.j + 1; j < 8; j++) {
					let s = chessBoard[this.square.i][j]
					if (predicate(s)) {
						moves.push(s)
						if (s.piece && s.piece.color != this.color) break
					} else break
				}

				return moves
			}
		}
		
		class Bishop extends Piece {
			constructor(color) {
				super('bishop', color) 
			}
			getSymbol() {
				return (this.color == COLOR.BLACK) ? "&#9821;" : "&#9815;"	
			}
			getPossibleMoves() {
				let moves = []
				const predicate = (square) => (square && !square.piece) || (square && square.piece && square.piece.color != this.color)

				for (let i = this.square.i+1, j = this.square.j+1; i < 8 && j < 8; i++,j++) {
					let s = chessBoard[i][j]
					if (predicate(s)) {
						moves.push(s)
						if (s.piece && s.piece.color != this.color) break
					} else break
				}
				for (let i = this.square.i-1, j = this.square.j+1; i >= 0 && j < 8; i--,j++) {
					let s = chessBoard[i][j]
					if (predicate(s)) {
						moves.push(s)
						if (s.piece && s.piece.color != this.color) break
					} else break
				}

				for (let i = this.square.i+1, j = this.square.j-1; i < 8 && j >= 0; i++,j--) {
					let s = chessBoard[i][j]
					if (predicate(s)) {
						moves.push(s)
						if (s.piece && s.piece.color != this.color) break
					} else break
				}
				for (let i = this.square.i-1, j = this.square.j-1; i >= 0 && j >= 0; i--,j--) {
					let s = chessBoard[i][j]
					if (predicate(s)) {
						moves.push(s)
						if (s.piece && s.piece.color != this.color) break
					} else break
				}
				return moves
			}
		}

		class Queen extends Piece {
			constructor(color) {
				super('queen', color) 
			}
			getSymbol() {
				return (this.color == COLOR.BLACK) ? "&#9819;" : "&#9813;"	
			}
			getPossibleMoves() {
				let queenSquare = this.square
				let bishop = new Bishop(this.color); bishop.square = queenSquare
				let rook = new Rook(this.color); rook.square = queenSquare
				return bishop.getPossibleMoves().concat(rook.getPossibleMoves())
			}
		}

		class King extends Piece {
			constructor(color) {
				super('king', color) 
			}
			getSymbol() {
				return (this.color == COLOR.BLACK) ? "&#9818;" : "&#9812;"	
			}
			getPossibleMoves() {
				let moves = []
				const predicate = (square) => (square && !square.piece) || (square && square.piece && square.piece.color != this.color)
				let directions = [
					{di:0,dj:-1},{di:0,dj:1},
					{di:1,dj:1},{di:1,dj:0},{di:1,dj:-1},
					{di:-1,dj:1},{di:-1,dj:0},{di:-1,dj:-1},
					]
				const me = this
				directions.forEach(d => {
					let {di,dj} = d
					let s = neighbour(me.square, di, dj)
					if (predicate(s)) {
						moves.push(s)
					}
				})
				return moves
			}
		}

		function neighbour(square, dx, dy) {
			const newI = square.i + dx
			const newJ = square.j + dy
			if ((newI < 0 || newI > 7) || (newJ < 0 || newJ > 7)) return null
			return chessBoard[newI][newJ]
		}
		
		function lightPossibleMoves(piece) {
			piece.getPossibleMoves().filter(s => s != null).map( s => s.highlighted = true)
		}

		function clearSelectedSquares() {
			selectedSquare = null
			chessBoard.map(row => row.map(square => {
					square.selected = false
					square.highlighted = false
				}
			))
		}
		function canMovePiece(piece, newSquare) {
			const canMove = piece.getPossibleMoves().includes(newSquare)
			//console.log("can move = "+ canMove)
			return canMove
		}

		function addSquareClickListener(square) {
			// click on square
			square.addEventListener('click', function(e) {
				e.preventDefault();
				let div = e.target
				clickSquareEvent(div)
			}, false);
		}
		
		function addPieceClickListener() {
			let pieces = document.querySelectorAll("div[id^='piece']")
			
			pieces.forEach( piece => {
				piece.addEventListener('click', function(e) {
					e.preventDefault();
					clickSquareEvent(e.target.parentElement)
				}, false);
			})
		}

		function clickSquareEvent(squareElement) {
			let i = squareElement.getAttribute("data-i")
			let j = squareElement.getAttribute("data-j")
			if (!i || !j) return
			let newSquare = chessBoard[i][j]
			if (!newSquare) return
			
			if (!selectedSquare && !newSquare.piece) return 

			// new piece selected
			if (!selectedSquare && newSquare.piece) {
				return selectNewSquare(newSquare)
			}
			
			// move a piece
			if (selectedSquare && selectedSquare.piece && newSquare && selectedSquare != newSquare) {
				
				if (canMovePiece(selectedSquare.piece, newSquare)) {
					selectedSquare.piece.beforeMoveEvent(newSquare)
					newSquare.setPiece(selectedSquare.piece)
					selectedSquare.piece.afterMoveEvent()
					startPieceAnimation(selectedSquare, newSquare)
					selectedSquare.piece = null
				} else {
					if (newSquare.piece) { // if because you select another piece
						return selectNewSquare(newSquare)
					}
				}
				setTimeout(function () {
					clearSelectedSquares()
					drawBoard();
				}, 300);
			}
		}

		function getCoords(elem) {
			let box = elem.getBoundingClientRect();

			return {
				top: box.top + pageYOffset,
				left: box.left + pageXOffset
			};
		}

		function startPieceAnimation(oldSquare, newSquare) {
			let oldSquareCoord = getCoords(document.getElementById(oldSquare.getHtmlId()))
			let newSquareCoord = getCoords(document.getElementById(newSquare.getHtmlId()))
			console.log(`from ${oldSquareCoord.top},${oldSquareCoord.left} to -> ${newSquareCoord.top},${newSquareCoord.left}`)
			let dx = Math.round(newSquareCoord.left - oldSquareCoord.left)
			let dy = Math.round(newSquareCoord.top - oldSquareCoord.top)
			
			document.getElementById(oldSquare.piece.getHtmlId()).animate(
			[
				{ transform: `translate(0px, 0px)` },
				{ transform: `translate(${dx}px, ${dy}px)` },
				
			], {
				duration: 300,
				fill: "forwards"
			}
			);
		}

		function selectNewSquare(newSquare) {
			clearSelectedSquares()
			lightPossibleMoves(newSquare.piece)
			selectedSquare = newSquare
			selectedSquare.selected = true
			drawBoard()
		}

		function drawBoard() {
			let board = document.getElementById("board")
			board.innerHTML = ""
			
			for (var i = 0; i < 8; i++) {
				for (var j = 0; j < 8; j++) {
					let square = chessBoard[i][j]
					board.innerHTML += square.getHTML()
				}
				board.innerHTML += "<br style='clear:both;'>";
			}
			
			
			for (var i = 0; i < 8; i++) {
				for (var j = 0; j < 8; j++) {
					addSquareClickListener(document.getElementById("c-"+i+"-"+j))	
				}
			}
			
			addPieceClickListener()

			// draw moves history
			let movesDiv = document.getElementById("moves")
			movesDiv.innerHTML = "<ul>"
			moves.forEach( move => movesDiv.innerHTML += `<li>${move.getString()}</li>`)
			movesDiv.innerHTML += "<ul>"
		}
		
		function initBoard() {
			for (var i = 0; i < 8; i++) {
				chessBoard.push([])
				for (var j = 0; j < 8; j++) {
					let square = new Square(i, j, (i+j)%2==0 ? 'white':'black')
					chessBoard[i].push(square)
				}
			}
			addPieces();
		}
		
		function addPiece(i = 0, j = 0, piece) {
			chessBoard[i][j].setPiece(piece)
		}
		
		function addPieces() {
			// blacks
			//Array(8).fill().map((e,n) => addPiece(1, n, new Pawn(COLOR.BLACK)))
			addPiece(0, 0, new Rook(COLOR.BLACK))
			addPiece(0, 1, new Knight(COLOR.BLACK))
			addPiece(0, 2, new Bishop(COLOR.BLACK))
			addPiece(0, 3, new Queen(COLOR.BLACK))
			addPiece(0, 4, new King(COLOR.BLACK))

			// whites
			Array(8).fill().map((e,n) => addPiece(6, n, new Pawn(COLOR.WHITE)))
			addPiece(7, 3, new Queen(COLOR.WHITE))
			addPiece(7, 4, new King(COLOR.WHITE))
		}

		initBoard();
		drawBoard();
	</script>
</body
</html>